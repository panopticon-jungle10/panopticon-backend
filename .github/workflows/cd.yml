name: CD - Build & Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_ACCOUNT_ID: ${{ secrets.ECR_ACCOUNT_ID }}
  QUERY_ECR_REPOSITORY: ${{ secrets.QUERY_ECR_REPOSITORY }}
  QUERY_ECS_CLUSTER: ${{ secrets.QUERY_ECS_CLUSTER }}
  QUERY_ECS_SERVICE: ${{ secrets.QUERY_ECS_SERVICE }}
  STREAM_ECR_REPOSITORY: ${{ secrets.STREAM_ECR_REPOSITORY }}
  STREAM_ECS_CLUSTER: ${{ secrets.STREAM_ECS_CLUSTER }}
  STREAM_ECS_SERVICE: ${{ secrets.STREAM_ECS_SERVICE }}
  STREAM_TASK_DEFINITION: ${{ secrets.STREAM_TASK_DEFINITION }}
  STREAM_CONTAINER_NAME: ${{ secrets.STREAM_CONTAINER_NAME }}
  QUERY_TASK_DEFINITION: ${{ secrets.QUERY_TASK_DEFINITION }}
  QUERY_CONTAINER_NAME: ${{ secrets.QUERY_CONTAINER_NAME }}
  ERROR_STREAM_ECR_REPOSITORY: ${{ secrets.ERROR_STREAM_ECR_REPOSITORY }}
  ERROR_STREAM_ECS_CLUSTER: ${{ secrets.ERROR_STREAM_ECS_CLUSTER }}
  ERROR_STREAM_ECS_SERVICE: ${{ secrets.ERROR_STREAM_ECS_SERVICE }}
  ERROR_STREAM_TASK_DEFINITION: ${{ secrets.ERROR_STREAM_TASK_DEFINITION }}
  ERROR_STREAM_CONTAINER_NAME: ${{ secrets.ERROR_STREAM_CONTAINER_NAME }}
  AGGREGATOR_ECR_REPOSITORY: ${{ secrets.AGGREGATOR_ECR_REPOSITORY }}
  AGGREGATOR_ECS_CLUSTER: ${{ secrets.AGGREGATOR_ECS_CLUSTER }}
  AGGREGATOR_ECS_SERVICE: ${{ secrets.AGGREGATOR_ECS_SERVICE }}
  AGGREGATOR_TASK_DEFINITION: ${{ secrets.AGGREGATOR_TASK_DEFINITION }}
  AGGREGATOR_CONTAINER_NAME: ${{ secrets.AGGREGATOR_CONTAINER_NAME }}
  PRODUCER_ECR_REPOSITORY: ${{ secrets.PRODUCER_ECR_REPOSITORY }}
  PRODUCER_ECS_CLUSTER: ${{ secrets.PRODUCER_ECS_CLUSTER }}
  PRODUCER_ECS_SERVICE: ${{ secrets.PRODUCER_ECS_SERVICE }}
  PRODUCER_TASK_DEFINITION: ${{ secrets.PRODUCER_TASK_DEFINITION }}
  PRODUCER_CONTAINER_NAME: ${{ secrets.PRODUCER_CONTAINER_NAME }}

jobs:
  detect:
    name: Detect changed components
    runs-on: ubuntu-latest
    outputs:
      query_api: ${{ steps.filter.outputs.query_api }}
      stream_processor: ${{ steps.filter.outputs.stream_processor }}
      error_stream: ${{ steps.filter.outputs.error_stream }}
      aggregator: ${{ steps.filter.outputs.aggregator }}
      producer: ${{ steps.filter.outputs.producer }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Detect paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            query_api:
              - 'backend/src/query-api/**'
              - 'backend/src/shared/**'
              - 'backend/package.json'
              - 'backend/package-lock.json'
              - 'backend/Dockerfile'
            stream_processor:
              - 'backend/src/stream-processor/**'
              - 'backend/src/shared/**'
              - 'backend/package.json'
              - 'backend/package-lock.json'
              - 'backend/Dockerfile'
            error_stream:
              - 'backend/src/error-stream/**'
              - 'backend/src/shared/**'
              - 'backend/package.json'
              - 'backend/package-lock.json'
              - 'backend/Dockerfile'
            aggregator:
              - 'backend/src/aggregator/**'
              - 'backend/src/shared/**'
              - 'backend/package.json'
              - 'backend/package-lock.json'
              - 'backend/Dockerfile'
            producer:
              - 'producerServer/src/**'
              - 'producerServer/Dockerfile'

  deploy-query:
    name: Build & deploy query API
    needs: detect
    if: needs.detect.outputs.query_api == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        working-directory: backend
        env:
          IMAGE_NAME: panopticon-query-api
        run: |
          docker build -f Dockerfile --target query-api -t "$IMAGE_NAME:${GITHUB_SHA}" .

      - name: Push image to ECR
        env:
          IMAGE_NAME: panopticon-query-api
        run: |
          ECR_URI="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${QUERY_ECR_REPOSITORY}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:${GITHUB_SHA}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${GITHUB_SHA}"
          docker push "${ECR_URI}:latest"
          echo "QUERY_ECR_URI=${ECR_URI}" >> $GITHUB_ENV

      - name: Register new task definition revision
        run: |
          aws ecs describe-task-definition --task-definition "$QUERY_TASK_DEFINITION" --query 'taskDefinition' --output json > task-def.json
          IMAGE="${{ env.QUERY_ECR_URI }}:${GITHUB_SHA}"
          cat task-def.json | jq --arg IMAGE "$IMAGE" --arg NAME "$QUERY_CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .registeredAt, .registeredBy, .compatibilities)
          ' > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "QUERY_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Trigger ECS deployment
        run: |
          aws ecs update-service \
            --cluster "$QUERY_ECS_CLUSTER" \
            --service "$QUERY_ECS_SERVICE" \
            --task-definition "$QUERY_TASK_DEF_ARN" \
            --force-new-deployment

  deploy-stream:
    name: Build & deploy stream processor
    needs: detect
    if: needs.detect.outputs.stream_processor == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        working-directory: backend
        env:
          IMAGE_NAME: panopticon-stream-processor
        run: |
          docker build -f Dockerfile --target stream-processor -t "$IMAGE_NAME:${GITHUB_SHA}" .

      - name: Push image to ECR
        env:
          IMAGE_NAME: panopticon-stream-processor
        run: |
          ECR_URI="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${STREAM_ECR_REPOSITORY}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:${GITHUB_SHA}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${GITHUB_SHA}"
          docker push "${ECR_URI}:latest"
          echo "STREAM_ECR_URI=${ECR_URI}" >> $GITHUB_ENV

      - name: Register new task definition revision
        run: |
          aws ecs describe-task-definition --task-definition "$STREAM_TASK_DEFINITION" --query 'taskDefinition' --output json > task-def.json
          IMAGE="${{ env.STREAM_ECR_URI }}:${GITHUB_SHA}"
          cat task-def.json | jq --arg IMAGE "$IMAGE" --arg NAME "$STREAM_CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .registeredAt, .registeredBy, .compatibilities)
          ' > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "STREAM_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Trigger ECS deployment
        run: |
          aws ecs update-service \
            --cluster "$STREAM_ECS_CLUSTER" \
            --service "$STREAM_ECS_SERVICE" \
            --task-definition "$STREAM_TASK_DEF_ARN" \
            --force-new-deployment

  deploy-error-stream:
    name: Build & deploy error stream
    needs: detect
    if: needs.detect.outputs.error_stream == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        working-directory: backend
        env:
          IMAGE_NAME: panopticon-error-stream
        run: |
          docker build -f Dockerfile --target error-stream -t "$IMAGE_NAME:${GITHUB_SHA}" .

      - name: Push image to ECR
        env:
          IMAGE_NAME: panopticon-error-stream
        run: |
          ECR_URI="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ERROR_STREAM_ECR_REPOSITORY}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:${GITHUB_SHA}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${GITHUB_SHA}"
          docker push "${ECR_URI}:latest"
          echo "ERROR_STREAM_ECR_URI=${ECR_URI}" >> $GITHUB_ENV

      - name: Register new task definition revision
        run: |
          aws ecs describe-task-definition --task-definition "$ERROR_STREAM_TASK_DEFINITION" --query 'taskDefinition' --output json > task-def.json
          IMAGE="${{ env.ERROR_STREAM_ECR_URI }}:${GITHUB_SHA}"
          cat task-def.json | jq --arg IMAGE "$IMAGE" --arg NAME "$ERROR_STREAM_CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .registeredAt, .registeredBy, .compatibilities)
          ' > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "ERROR_STREAM_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Trigger ECS deployment
        run: |
          aws ecs update-service \
            --cluster "$ERROR_STREAM_ECS_CLUSTER" \
            --service "$ERROR_STREAM_ECS_SERVICE" \
            --task-definition "$ERROR_STREAM_TASK_DEF_ARN" \
            --force-new-deployment

  deploy-aggregator:
    name: Build & deploy rollup aggregator
    needs: detect
    if: needs.detect.outputs.aggregator == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        working-directory: backend
        env:
          IMAGE_NAME: panopticon-aggregator
        run: |
          docker build -f Dockerfile --target aggregator -t "$IMAGE_NAME:${GITHUB_SHA}" .

      - name: Push image to ECR
        env:
          IMAGE_NAME: panopticon-aggregator
        run: |
          ECR_URI="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${AGGREGATOR_ECR_REPOSITORY}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:${GITHUB_SHA}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${GITHUB_SHA}"
          docker push "${ECR_URI}:latest"
          echo "AGGREGATOR_ECR_URI=${ECR_URI}" >> $GITHUB_ENV

      - name: Register new task definition revision
        run: |
          aws ecs describe-task-definition --task-definition "$AGGREGATOR_TASK_DEFINITION" --query 'taskDefinition' --output json > task-def.json
          IMAGE="${{ env.AGGREGATOR_ECR_URI }}:${GITHUB_SHA}"
          cat task-def.json | jq --arg IMAGE "$IMAGE" --arg NAME "$AGGREGATOR_CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .registeredAt, .registeredBy, .compatibilities)
          ' > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "AGGREGATOR_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Trigger ECS deployment
        run: |
          aws ecs update-service \
            --cluster "$AGGREGATOR_ECS_CLUSTER" \
            --service "$AGGREGATOR_ECS_SERVICE" \
            --task-definition "$AGGREGATOR_TASK_DEF_ARN" \
            --force-new-deployment

  deploy-producer:
    name: Build & deploy producer
    needs: detect
    if: needs.detect.outputs.producer == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        working-directory: producerServer
        env:
          IMAGE_NAME: panopticon-producer
        run: |
          docker build -f Dockerfile -t "$IMAGE_NAME:${GITHUB_SHA}" .

      - name: Push image to ECR
        env:
          IMAGE_NAME: panopticon-producer
        run: |
          ECR_URI="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${PRODUCER_ECR_REPOSITORY}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:${GITHUB_SHA}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${GITHUB_SHA}"
          docker push "${ECR_URI}:latest"
          echo "PRODUCER_ECR_URI=${ECR_URI}" >> $GITHUB_ENV

      - name: Register new task definition revision
        run: |
          aws ecs describe-task-definition --task-definition "$PRODUCER_TASK_DEFINITION" --query 'taskDefinition' --output json > task-def.json
          IMAGE="${{ env.PRODUCER_ECR_URI }}:${GITHUB_SHA}"
          cat task-def.json | jq --arg IMAGE "$IMAGE" --arg NAME "$PRODUCER_CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .registeredAt, .registeredBy, .compatibilities)
          ' > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "PRODUCER_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Trigger ECS deployment
        run: |
          aws ecs update-service \
            --cluster "$PRODUCER_ECS_CLUSTER" \
            --service "$PRODUCER_ECS_SERVICE" \
            --task-definition "$PRODUCER_TASK_DEF_ARN" \
            --force-new-deployment
